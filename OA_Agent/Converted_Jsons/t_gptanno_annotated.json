{
  "description": "This Python script performs single-cell RNA sequencing (scRNA-seq) data analysis, including preprocessing, clustering, visualization, and cell type annotation using both marker genes and large language models (LLMs). Here's a breakdown of the script's functionality and structure:\n\n**1. Setup and Library Imports (Lines 1-5):**\n\n*   **`import omicverse as ov`**: Imports the `omicverse` library (presumably a specialized scRNA-seq analysis library) and assigns it the alias `ov`.\n*   **`print(f'omicverse version:{ov.__version__}')`**: Prints the version of the `omicverse` library being used.\n*   **`import scanpy as sc`**: Imports the `scanpy` library, a popular scRNA-seq analysis tool, and assigns it the alias `sc`.\n*   **`print(f'scanpy version:{sc.__version__}')`**: Prints the version of the `scanpy` library.\n*   **`ov.ov_plot_set()`**: Sets a specific plotting style using the `omicverse` library, ensuring consistent visual outputs.\n\n**2. Data Loading (Lines 10-13):**\n\n*   **`adata = sc.read_10x_mtx(...)`**: Reads data from a 10x Genomics output matrix (`.mtx`) file into an `AnnData` object (a data structure used by `scanpy` and `omicverse`).\n    *   **`'data/filtered_gene_bc_matrices/hg19/'`**: Specifies the directory containing the 10x matrix file.\n    *   **`var_names='gene_symbols'`**: Sets gene symbols as the names of the variables (genes).\n    *   **`cache=True`**: Enables caching the loaded data for faster subsequent reads.\n\n**3. Data Preprocessing (Lines 17-34):**\n\n*   **`adata = ov.pp.qc(adata, tresh={...})`**: Performs quality control (QC) filtering:\n    *   Filters out cells based on: mitochondrial percentage (`mito_perc` less than 0.05), number of UMIs (`nUMIs` greater than 500), and the number of detected genes (`detected_genes` greater than 250).\n*   **`adata = ov.pp.preprocess(adata, mode='shiftlog|pearson', n_HVGs=2000)`**: Applies preprocessing steps:\n    *   Likely includes normalization and transformation (e.g. shiftlog).\n    *   Selects the top 2000 highly variable genes (HVGs) using a Pearson method.\n*   **`adata.raw = adata`**: Stores the raw (preprocessed) data into the `.raw` attribute. This is useful to recover the raw expression data later.\n*   **`adata = adata[:, adata.var.highly_variable_features]`**: Filters the AnnData object to keep only the HVGs.\n*   **`ov.pp.scale(adata)`**: Scales the gene expression data to zero mean and unit variance for each gene.\n*   **`ov.pp.pca(adata, layer='scaled', n_pcs=50)`**: Performs Principal Component Analysis (PCA) on the scaled data and reduces to 50 principal components (PCs).\n*   **`sc.pp.neighbors(adata, n_neighbors=15, n_pcs=50, use_rep='scaled|original|X_pca')`**: Constructs a neighborhood graph based on the scaled data, using both the original expression, and the PCA embeddings.\n\n**4. Clustering and Gene Ranking (Lines 37-42):**\n\n*   **`sc.tl.leiden(adata)`**: Performs Leiden clustering, identifying clusters of cells based on gene expression similarity.\n*   **`sc.tl.dendrogram(adata, 'leiden', use_rep='scaled|original|X_pca')`**:  Computes a dendrogram based on the Leiden clusters, which can show the similarity relationships among clusters.\n*   **`sc.tl.rank_genes_groups(adata, 'leiden', use_rep='scaled|original|X_pca', method='wilcoxon', use_raw=False)`**: Ranks genes based on differential expression between Leiden clusters using the Wilcoxon test, does not use the raw data. This identifies genes that are characteristic of each cluster.\n\n**5. Embedding and Visualization (Lines 45-54):**\n\n*   **`adata.obsm[\"X_mde\"] = ov.utils.mde(adata.obsm[\"scaled|original|X_pca\"])`**: Computes a Manifold Diffusion Embedding (MDE) and stores it in `adata.obsm` for visualization.\n*   **`adata`**: Displays the contents of the AnnData object.\n*   **`ov.pl.embedding(...)`**: Generates an embedding plot:\n    *   **`basis='X_mde'`**: Uses MDE for the 2D coordinates.\n    *   **`color=['leiden']`**: Colors the plot according to the Leiden clusters.\n    *   Other parameters configure the appearance of the plot (legend, frame, color palette).\n\n**6. Cell Type Annotation using LLMs (Lines 56-124):**\n\n*   **Marker Gene Definition (Lines 57-58, 93-94):** Defines a dictionary of marker genes (`all_markers`) associated with different clusters.\n*   **API Key Setup (Lines 60, 72, 96, 102, 108, 114):** Sets the API key for accessing the LLMs using the `os` library and environment variables.\n*   **LLM-Based Cell Type Prediction (`ov.single.gptcelltype` and `ov.single.gptcelltype_local`) (Lines 61-63, 73-75, 97-99, 103-105, 109-111, 115-117, 122-124):**\n    *   These functions use LLMs (like `qwen-plus`, `gpt-4o`, `moonshot-v1-8k`) to predict cell types based on the input marker genes.\n    *   The script tests several different LLMs from different providers (OpenAI, Qwen, Kimi) for the same marker gene input.\n    *   `tissuename`, `speciename`, and `topgenenumber` parameters provide context and control.\n    *   `ov.single.gptcelltype` likely calls a remote API endpoint for the LLM.\n    *   `ov.single.gptcelltype_local` uses a locally hosted LLM at the defined model path.\n*   **Marker Gene Generation (Lines 66-68):**\n    *   **`all_markers = ov.single.get_celltype_marker(...)`**:  Identifies marker genes from the `adata` object, based on the Leiden clusters, the ranked genes, a fold change threshold, and the number of top genes.\n*   **Result Processing (Lines 78-81):**\n    *   Extracts the predicted cell type names from the results returned by the LLM.\n*   **Annotation Integration (Line 83):**\n    *   **`adata.obs['gpt_celltype'] = adata.obs['leiden'].map(new_result).astype('category')`**:  Adds the predicted cell types as a new category (`gpt_celltype`) to the AnnData object.\n*   **Cell Type Visualization (Lines 85-91):**\n    *   Generates another embedding plot with both Leiden clusters and the predicted `gpt_celltype` annotations.\n\n**In summary, this script:**\n\n1.  Loads and preprocesses scRNA-seq data.\n2.  Performs clustering and ranks genes.\n3.  Visually represents the data using embeddings.\n4.  Leverages LLMs to predict cell types based on both user-defined marker genes and marker genes automatically identified from the clustering analysis.\n5.  Evaluates multiple LLMs from multiple providers (OpenAI, Qwen, Kimi), including a local model.\n6.  Integrates predicted cell types as an annotation in the AnnData object and visualizes them on the same embedding as Leiden clustering.\n\n**Key Features:**\n\n*   Uses both `omicverse` and `scanpy` for single-cell analysis, leveraging the functionalities of both libraries.\n*   Demonstrates a workflow incorporating LLMs for cell type annotation, utilizing both marker gene sets and the ranked genes from clustering.\n*   Explores multiple large language models with different providers, highlighting the flexibility of using LLMs for cell annotation.\n*   Integrates the LLM predictions into the AnnData object.\n*   Includes extensive visualizations throughout the analysis, demonstrating different aspects of the data.\n\nThis script is well-commented, making it easy to understand the purpose of each step. It provides a good example of how to perform single-cell RNA sequencing analysis and integrate it with the power of large language models for cell type annotation.",
  "file": "t_gptanno_annotated.py"
}