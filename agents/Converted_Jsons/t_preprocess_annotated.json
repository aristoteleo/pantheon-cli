{
  "description": "This Python script performs single-cell RNA sequencing (scRNA-seq) data analysis using the `omicverse` and `scanpy` libraries. It reads in data, performs quality control, normalization, dimensionality reduction, clustering, differential gene expression analysis, and visualization. Here's a breakdown of its functionality and structure:\n\n**1. Setup and Data Loading (Lines 1-12):**\n\n*   **Imports:**\n    *   `omicverse` as `ov`: Provides a high-level API for scRNA-seq analysis, building on top of `scanpy`.\n    *   `scanpy` as `sc`:  A foundational library for single-cell analysis in Python.\n*   **Plotting Style:** `ov.ov_plot_set()`: Sets a default plotting style for `omicverse` visualizations.\n*   **Data Loading:**\n    *   `sc.read_10x_mtx()`: Reads 10x Genomics matrix data (containing gene expression counts for each cell) from a specified directory (`data/filtered_gene_bc_matrices/hg19/`) into an `AnnData` object. The `AnnData` is a data structure used by `scanpy` and `omicverse` to store data and metadata related to single-cell experiments.\n    *   `var_names='gene_symbols'`: Ensures gene symbols are used as feature (variable) names in the `AnnData`.\n    *   `cache=True`: Enables caching for faster subsequent reads of the data.\n\n**2. Data Preprocessing (Lines 14-29):**\n\n*   **Making Names Unique:**\n    *   `adata.var_names_make_unique()`: Ensures feature names (gene symbols) are unique, handling duplicates if necessary.\n    *   `adata.obs_names_make_unique()`: Ensures cell names are unique.\n*   **Quality Control (QC):**\n    *   `ov.pp.qc()`: Performs quality control filtering using thresholds for:\n        *   `mito_perc`: Percentage of reads mapping to mitochondrial genes (cells with high mitochondrial percentage might be of low quality).\n        *   `nUMIs`: Number of unique molecular identifiers (UMIs) or total reads per cell.\n        *   `detected_genes`: Number of genes detected in each cell. Cells with very low number of detected genes might be of poor quality.\n*   **Storing Counts Layer:**\n    *   `ov.utils.store_layers(adata,layers='counts')`: Saves the raw count data in a separate layer called 'counts' in the `AnnData` object. This preserves the raw data before any transformations.\n*   **Preprocessing:**\n    *   `ov.pp.preprocess()`: Normalizes and transforms the data for analysis.\n        *  `mode='shiftlog|pearson'`: Applies a shiftlog transformation and Pearson scaling (or using pearson as HVGs).\n        *  `n_HVGs=2000`: Selects the 2000 most highly variable genes (HVGs) for downstream analysis.\n*  **Storing Raw Data and Filtering:**\n    * `adata.raw = adata`: Stores a copy of the current state of data into the `raw` attribute of `AnnData`.\n    * `adata = adata[:, adata.var.highly_variable_features]`: Filters the `AnnData` to keep only the highly variable genes selected in the preprocessing step.\n\n**3. Data Handling and Validation (Lines 31-42):**\n\n*   **Copying AnnData and Layer Retrieval:**\n    *   `adata_counts=adata.copy()`: Makes a copy of the `AnnData` object.\n    *   `ov.utils.retrieve_layers(adata_counts,layers='counts')`: Retrieve stored layers named `counts` in `adata_counts`.\n*   **Data Inspection:**\n    *   `print('normalize adata:',adata.X.max())`: Prints the maximum value in the normalized data matrix (`adata.X`).\n    *   `print('raw count adata:',adata_counts.X.max())`: Prints the maximum value of raw counts data in adata_counts.\n* **Re-Copying Raw Data and Layer Retrieval**\n     *   `adata_counts=adata.raw.to_adata().copy()`: Makes a copy of the data stored in `adata.raw` into `adata_counts`\n     * `ov.utils.retrieve_layers(adata_counts,layers='counts')`: Retrieve stored layers named `counts` in `adata_counts`.\n*   **Data Inspection:**\n    *   `print('normalize adata:',adata.X.max())`: Prints the maximum value in the normalized data matrix (`adata.X`).\n    *   `print('raw count adata:',adata_counts.X.max())`: Prints the maximum value of raw counts data in adata_counts.\n    * This section validates that the saved counts layers are correct by printing their maximum values.\n\n**4. Dimensionality Reduction (Lines 44-60):**\n\n*   **Scaling:**\n    *   `ov.pp.scale(adata)`: Scales the data such that each gene has a mean of 0 and a variance of 1.\n*   **Principal Component Analysis (PCA):**\n    *   `ov.pp.pca(adata, layer='scaled', n_pcs=50)`: Performs PCA on the scaled data, reducing its dimensionality to 50 principal components.\n*   **Assigning PCA Embedding and Plotting:**\n    *   `adata.obsm['X_pca']=adata.obsm['scaled|original|X_pca']`: Assigns the scaled pca embedding to the `X_pca` slot in the AnnData object.\n    *  `ov.utils.embedding(...)`: Generates an embedding plot using `X_pca` for the visualization, colored by the expression level of the gene 'CST3'.\n*   **Neighborhood Graph and Multidimensional Energy Scaling (MDE):**\n     *  `sc.pp.neighbors()`: Calculates a nearest-neighbor graph based on the PCA embedding.\n     *  `ov.utils.mde()`: Computes a MDE embedding based on the PCA embedding.\n\n**5. Further Dimensionality Reduction and Clustering (Lines 62-79):**\n\n*   **MDE Embedding Plot:**\n    *   `ov.utils.embedding(...)`: Generates an embedding plot using `X_mde` for visualization, colored by 'CST3' gene expression.\n*   **UMAP:**\n    *  `sc.tl.umap()`: Performs UMAP dimensionality reduction.\n*   **UMAP Embedding Plot:**\n    *   `ov.utils.embedding(...)`: Generates an embedding plot using `X_umap` for visualization, colored by 'CST3' gene expression.\n*   **Leiden Clustering:**\n    *   `sc.tl.leiden(adata)`: Performs Leiden clustering, a graph-based community detection algorithm.\n*   **MDE Embedding Plot (with Cluster and Gene Coloring):**\n    *   `ov.utils.embedding(...)`: Generates an embedding plot using `X_mde` for visualization, colored by Leiden cluster assignments, 'CST3' gene expression and `NKG7` gene expression.\n\n**6. Convex Hull and Labeling of Clusters (Lines 81-116):**\n\n*   **Matplotlib Imports:**\n    *   `import matplotlib.pyplot as plt`: Imports the matplotlib plotting library.\n*   **Setting up Matplotlib Axes**\n    *   `fig,ax=plt.subplots( figsize = (4,4))`: Creates a matplotlib figure and axes object.\n*   **Embedding plot and Convex Hull:**\n    *   `ov.utils.embedding()`: Creates an embedding plot for X_mde with leiden coloring.\n    *  `ov.utils.plot_ConvexHull()`: Plots a convex hull around the cluster '0' in the `X_mde` embedding.\n*   **Matplotlib Imports**\n    * `from matplotlib import patheffects`: Imports the patheffects module of the matplotlib plotting library.\n    * `import matplotlib.pyplot as plt`: Imports the matplotlib plotting library.\n    * `fig, ax = plt.subplots(figsize=(4,4))`: Creates a matplotlib figure and axes object.\n*   **Embedding plot and Label generation:**\n    * `ov.utils.embedding()`: Generates an embedding plot for X_mde with leiden coloring.\n    *   `ov.utils.gen_mpl_labels()`: Generates and adds labels to the embedding plot for each Leiden cluster, excluding 'None'. The labels have bold text, a white border (patheffects) and an arrow to the cluster centroid.\n\n**7. Marker Gene Analysis and Visualization (Lines 118-169):**\n\n*   **Marker Genes List:** Defines a list of marker genes associated with different cell types.\n*   **Dotplot of Marker Genes:**\n    *   `sc.pl.dotplot()`: Creates a dotplot showing expression levels of the marker genes across different Leiden clusters.\n*  **Dendrogram and Differential Expression Analysis:**\n   * `sc.tl.dendrogram()`: Computes a dendrogram based on the leiden clusters.\n    *  `sc.tl.rank_genes_groups()`: Identifies differentially expressed genes between clusters using a t-test on the scaled PCA embeddings. Results are stored with key `leiden_ttest`.\n   * `sc.pl.rank_genes_groups_dotplot()`: Generates dotplot of top ranked genes for each group from the t-test result.\n   *  `sc.tl.rank_genes_groups()`: Identifies differentially expressed genes between clusters using a t-test on the scaled PCA embeddings, without specifying key_added argument (so using default).\n   * `ov.single.cosg()`: Runs consensus scoring of gene groups.\n    *  `sc.pl.rank_genes_groups_dotplot()`: Generates a dotplot of top ranked genes from `cosg` result for each cluster.\n*   **Storing Ranked Genes Results:**\n    *   A loop iterates over each Leiden cluster, and the differential gene expression results (using t-test) are stored in the `data_dict` dictionary. The `sc.get.rank_genes_groups_df()` retrieves the results of the t-test for each cluster.\n*   **Printing data dictionary:**\n    * The script prints the keys of the `data_dict` to validate.\n    * The head of the dataframe stored in the dictionary is shown.\n*   **Creating color dictionary:**\n    *   The script creates a color dictionary for the leiden clusters using the `adata.uns['leiden_colors']` to map cluster name with colors.\n*   **Stacked Volcano Plot:**\n    *   `ov.utils.stacking_vol()`: Generates a stacked volcano plot, showing differential gene expression results for each Leiden cluster. Each subplot shows a volcano plot for one Leiden cluster.\n*   **Setting Y axis limit:**\n    *   The script sets a standard y axis limit for all the volcano plot subplots.\n*   **Setting plot title:**\n    *   The script sets a title for the whole plot.\n\n**In Summary:**\n\nThis script provides a comprehensive workflow for analyzing scRNA-seq data:\n\n1.  **Data Loading and QC:** Reads and cleans the data.\n2.  **Preprocessing:** Normalizes and selects variable genes.\n3.  **Dimensionality Reduction:** Reduces data dimensionality using PCA, MDE, and UMAP.\n4.  **Clustering:** Groups cells into clusters using Leiden.\n5.  **Visualization:**  Visualizes data using embedding plots, convex hulls, and dot plots.\n6.  **Differential Gene Expression:** Identifies marker genes for each cluster using t-test and cosg and visualizes the results in dot plots and stacked volcano plots.\n\nThis script is a good example of how to use `omicverse` and `scanpy` for a typical scRNA-seq analysis. It highlights the common steps involved in the analysis workflow.",
  "file": "t_preprocess_annotated.py"
}